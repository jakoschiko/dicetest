use crate::die::adapters::{BoxedDieOnce, FlatMapDie, FlattenDie, MapDie};
use crate::die::Limit;
use crate::prand::{Prng, Seed};

/// Trait for generating a single preudorandom value of type `T`.
pub trait DieOnce<T> {
    /// Consumes the generator and generates a preudorandom value.
    ///
    /// The `Prng` is the only source of the randomness. Besides that, the generation is
    /// derterministic. The `Limit` is meant as an upper size of the generated value, though
    /// it's depends on the implementation how `Limit` is interpreted.
    fn roll_once(self, prng: &mut Prng, limit: Limit) -> T;

    /// Creates a new `DieOnce` by mapping the generated values of `self`.
    ///
    /// The function `f` will be applied to the generated value of `self`. This function result
    /// is the generated value of the new `Die`.
    fn map_once<U, F>(self, f: F) -> MapDie<T, U, Self, F>
    where
        Self: Sized,
        F: FnOnce(T) -> U,
    {
        MapDie::new(self, f)
    }

    /// Creates a new `DieOnce` whose value is generated by the generated `DieOnce` of `self`.
    fn flatten_once<U>(self) -> FlattenDie<U, T, Self>
    where
        Self: Sized,
        T: DieOnce<U>,
    {
        FlattenDie::new(self)
    }

    /// Creates a new `DieOnce` similiar to `DieOnce::map_once`, except that the mapping produces
    /// a `DieOnce`.
    ///
    /// The function `f` will be applied to the generated value of `self`. This function result
    /// ia a `DieOnce` that generate the value for the new `Die`.
    ///
    /// It is semanticly equivalent to `self.map_once(f).flatten_once()`.
    fn flat_map_once<U, DU, F>(self, f: F) -> FlatMapDie<T, U, Self, DU, F>
    where
        Self: Sized,
        DU: DieOnce<U>,
        F: FnOnce(T) -> DU,
    {
        FlatMapDie::new(self, f)
    }

    /// Puts `self` behind a `Box` pointer.
    fn boxed_once<'a>(self) -> BoxedDieOnce<'a, T>
    where
        Self: Sized + 'a,
    {
        BoxedDieOnce::new(self)
    }

    /// Calls `roll_once` with random `Seed` and default `Limit`. Useful for debugging the
    /// generator.
    fn sample_once(self) -> T
    where
        Self: Sized,
    {
        self.sample_with_limit_once(Limit::default())
    }

    /// Calls `roll_once` with random `Seed` and the given `Limit`. Useful for debugging
    /// the generator.
    fn sample_with_limit_once(self, limit: Limit) -> T
    where
        Self: Sized,
    {
        let mut prng = Prng::from_seed(Seed::random());

        self.roll_once(&mut prng, limit)
    }
}
