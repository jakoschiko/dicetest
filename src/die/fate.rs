use crate::die::Limit;
use crate::prand::Prng;

/// Contains parameters for controlling the value generation with `DieOnce` and `Die`.
///
/// The first parameter is a `Prng`. It is the only source of randomness that a implementor of
/// `DieOnce` or `Die` is allowed to use. Using the `Prng` will mutate its state, but for the cause
/// of preventing misuse there is no direct write access to it.
///
/// The second parameter is a `Limit`. It's the upper limit for the size of dynamic data structures
/// generated by the implementor of `DieOnce` or `Die`. The implementor has only read access
/// to the `Limit`.
pub struct Fate<'a> {
    prng: &'a mut Prng,
    limit: Limit,
}

impl<'a> Fate<'a> {
    // It's important that `Fate` has no public constructor. Tests and generators take a `&mut Fate`
    // because they need to mutate the `Prng`, but they must not mutate the `Limit`. A public
    // constructor would allow to create an arbitrary `Fate<'static>` and assign it to the
    // `&mut Fate`. This approach is inspired by `std::fmt::Formatter`.

    /// Calls the function with a `Fate` containing the given parameters.
    pub fn run<T>(prng: &'a mut Prng, limit: Limit, f: impl FnOnce(&mut Fate) -> T) -> T {
        let mut fate = Fate { prng, limit };
        f(&mut fate)
    }

    /// Modifies the `Limit` temporarily and calls the function with the modified `Fate`.
    pub fn with_limit<T>(&mut self, limit: Limit, f: impl FnOnce(&mut Fate) -> T) -> T {
        let mut fate = Fate {
            prng: &mut self.prng,
            limit,
        };
        f(&mut fate)
    }

    /// Returns the next pseudorandom number generated with the underlying `Prng`.
    pub fn next_number(&mut self) -> u64 {
        self.prng.next_number()
    }

    /// Returns a `Prng` split off from the underlying `Prng`.
    pub fn fork_prng(&mut self) -> Prng {
        self.prng.fork()
    }

    /// Returns the underlying `Limit`.
    pub fn limit(&self) -> Limit {
        self.limit
    }
}
