use std::marker::PhantomData;

use crate::prelude::dice::*;

/// The value generated by [`fn_builder`].
///
/// [`fn_builder`]: fn.fn_builder.html
pub struct FnBuilder<I, O, IC, OD> {
    input_codie: IC,
    output_die: OD,
    prng: Prng,
    limit: Limit,
    _i: PhantomData<I>,
    _o: PhantomData<O>,
}

impl<I, O, IC, OD> FnBuilder<I, O, IC, OD>
where
    IC: Codie<I>,
    OD: DieOnce<O>,
{
    pub fn build_fn_once(self) -> impl FnOnce(I) -> O {
        move |input| {
            let randomness = self.input_codie.coroll(input);
            let mut prng = self.prng;
            prng.reseed(randomness);
            self.output_die.roll_once(&mut prng, self.limit)
        }
    }
}

impl<I, O, IC, OD> FnBuilder<I, O, IC, OD>
where
    IC: Codie<I>,
    OD: Die<O>,
{
    pub fn build_fn(self) -> impl Fn(I) -> O {
        move |input| {
            let randomness = self.input_codie.coroll(input);
            let mut prng = self.prng.clone();
            prng.reseed(randomness);
            self.output_die.roll(&mut prng, self.limit)
        }
    }

    pub fn build_fn_mut(mut self) -> impl FnMut(I) -> O {
        move |input| {
            let randomness = self.input_codie.coroll(input);
            let prng = &mut self.prng;
            prng.reseed(randomness);
            self.output_die.roll(prng, self.limit)
        }
    }
}

/// Generates a function builder.
///
/// The builder can be converted into an implementation of [`FnOnce`], [`FnMut`] or [`Fn`].
///
/// # Examples
///
/// This example generates a [`FnOnce`]:
/// ```
/// use dicetest::prelude::dice::*;
///
/// let f = dice::fn_builder(
///     codice::from_default_hasher(),
///     dice::u8(..),
/// ).sample_once().build_fn_once();
/// let x = f(42);
/// ```
///
/// This example generates a [`FnMut`]:
/// ```
/// use dicetest::prelude::dice::*;
///
/// let mut f = dice::fn_builder(
///     codice::from_default_hasher(),
///     dice::u8(..),
/// ).sample_once().build_fn_mut();
/// let x = f(42);
/// let y = f(42);
/// ```
///
/// This example generates a [`Fn`]:
/// ```
/// use dicetest::prelude::dice::*;
///
/// let f = dice::fn_builder(
///     codice::from_default_hasher(),
///     dice::u8(..),
/// ).sample_once().build_fn();
/// let x = f(42);
/// assert_eq!(x, f(42));
/// let y = f(71);
/// ```
///
/// [`FnOnce`]: https://doc.rust-lang.org/std/ops/trait.FnOnce.html
/// [`FnMut`]: https://doc.rust-lang.org/std/ops/trait.FnMut.html
/// [`Fn`]: https://doc.rust-lang.org/std/ops/trait.Fn.html
pub fn fn_builder<I, O, IC, OD>(
    input_codie: IC,
    output_die: OD,
) -> impl DieOnce<FnBuilder<I, O, IC, OD>>
where
    IC: Codie<I>,
    OD: DieOnce<O>,
{
    dice::from_fn_once(|fate| FnBuilder {
        input_codie,
        output_die,
        prng: fate.prng.fork(),
        limit: fate.limit,
        _i: PhantomData,
        _o: PhantomData,
    })
}
