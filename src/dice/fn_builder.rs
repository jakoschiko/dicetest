use std::marker::PhantomData;

use crate::prelude::dice::*;

/// The value generated by [`fn_builder`].
///
/// [`fn_builder`]: fn.fn_builder.html
pub struct FnBuilder<I, O, IC, OD> {
    input_codie: IC,
    output_die: OD,
    prng: Prng,
    limit: Limit,
    _i: PhantomData<I>,
    _o: PhantomData<O>,
}

impl<I, O, IC, OD> FnBuilder<I, O, IC, OD>
where
    IC: Codie<I>,
    OD: DieOnce<O>,
{
    pub fn build_fn_once(self) -> impl FnOnce(I) -> O {
        move |input| {
            let output_die = self.output_die;
            let randomness = self.input_codie.coroll(input);
            let mut prng = self.prng;
            prng.reseed(randomness);
            Fate::run(&mut prng, self.limit, move |fate| {
                output_die.roll_once(fate)
            })
        }
    }
}

impl<I, O, IC, OD> FnBuilder<I, O, IC, OD>
where
    IC: Codie<I>,
    OD: Die<O>,
{
    pub fn build_fn(self) -> impl Fn(I) -> O {
        move |input| {
            let output_die = &self.output_die;
            let randomness = self.input_codie.coroll(input);
            let mut prng = self.prng.clone();
            prng.reseed(randomness);
            Fate::run(&mut prng, self.limit, |fate| output_die.roll(fate))
        }
    }

    pub fn build_fn_mut(mut self) -> impl FnMut(I) -> O {
        move |input| {
            let output_die = &self.output_die;
            let randomness = self.input_codie.coroll(input);
            let prng = &mut self.prng;
            prng.reseed(randomness);
            Fate::run(prng, self.limit, |fate| output_die.roll(fate))
        }
    }
}

/// Generates a function builder.
///
/// The builder can be converted into an implementation of [`FnOnce`], [`FnMut`] or [`Fn`].
///
/// # Examples
///
/// This example generates a [`FnOnce`]:
/// ```
/// use dicetest::prelude::dice::*;
///
/// let mut prng = Prng::from_seed(0x5EED.into());
/// let limit = Limit::default();
///
/// Fate::run(&mut prng, limit, |fate| {
///     let f = dice::fn_builder(
///         codice::from_default_hasher(),
///         dice::u8(..),
///     ).roll_once(fate).build_fn_once();
///
///     let x = f(42);
/// });
/// ```
///
/// This example generates a [`FnMut`]:
/// ```
/// use dicetest::prelude::dice::*;
///
/// let mut prng = Prng::from_seed(0x5EED.into());
/// let limit = Limit::default();
///
/// Fate::run(&mut prng, limit, |fate| {
///     let mut f = dice::fn_builder(
///         codice::from_default_hasher(),
///         dice::u8(..),
///     ).roll_once(fate).build_fn_mut();
///
///     let x = f(42);
///     let y = f(42);
/// });
/// ```
///
/// This example generates a [`Fn`]:
/// ```
/// use dicetest::prelude::dice::*;
///
/// let mut prng = Prng::from_seed(0x5EED.into());
/// let limit = Limit::default();
///
/// Fate::run(&mut prng, limit, |fate| {
///     let f = dice::fn_builder(
///         codice::from_default_hasher(),
///         dice::u8(..),
///     ).roll_once(fate).build_fn();
///
///     let x = f(42);
///     let y = f(42);
///     assert_eq!(x, y);
/// });
/// ```
///
/// [`FnOnce`]: https://doc.rust-lang.org/std/ops/trait.FnOnce.html
/// [`FnMut`]: https://doc.rust-lang.org/std/ops/trait.FnMut.html
/// [`Fn`]: https://doc.rust-lang.org/std/ops/trait.Fn.html
pub fn fn_builder<I, O, IC, OD>(
    input_codie: IC,
    output_die: OD,
) -> impl DieOnce<FnBuilder<I, O, IC, OD>>
where
    IC: Codie<I>,
    OD: DieOnce<O>,
{
    dice::from_fn_once(|fate| FnBuilder {
        input_codie,
        output_die,
        prng: fate.fork_prng(),
        limit: fate.limit(),
        _i: PhantomData,
        _o: PhantomData,
    })
}
