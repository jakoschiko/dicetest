use std::marker::PhantomData;

use ::rng::Rng;
use ::gen::{Params, GenOnce};

/// Trait for generating random values of type `T`.
pub trait Gen<T>: GenOnce<T> {
    /// Generates a random value using the given parameters.
    ///
    /// The `Rng` is the only source of the randomness. Besides that, the generation is
    /// derterministic.
    fn gen(&self, &mut Rng, &Params) -> T;

    /// Creates a new `Gen` by mapping the generated values of `self`.
    ///
    /// The function `f` will be applied to the generated values of `self`. These function results
    /// are the generated values of the new `Gen`.
    fn map<U, F>(self, f: F) -> GenMap<T, U, Self, F>
    where
        Self: Sized,
        F: Fn(T) -> U,
    {
        GenMap {
            g: self,
            f,
            _t: PhantomData,
            _u: PhantomData,
        }
    }

    /// Creates a new `Gen` whose values are generated by the generated `Gen`s of `self`.
    fn flatten<U>(self) -> GenFlatten<U, T, Self>
    where
        Self: Sized,
        T: GenOnce<U>
    {
        GenFlatten {
            ggt: self,
            _t: PhantomData,
            _gt: PhantomData,
        }
    }

    /// Creates a new `Gen` similiar to `Gen::map`, except that the mapping produces `Gen`s.
    ///
    /// The function `f` will be applied to the generated values of `self`. These function results
    /// are `Gen`s that generates the values for the new `Gen`.
    ///
    /// It is semanticly equivalent to `self.map(f).flatten()`.
    fn flat_map<U, GU, F>(self, f: F) -> GenFlatMap<T, U, Self, GU, F>
    where
        Self: Sized,
        GU: GenOnce<U>,
        F: Fn(T) -> GU,
    {
        GenFlatMap {
            gt: self,
            f,
            _t: PhantomData,
            _u: PhantomData,
            _gu: PhantomData,
        }
    }

    /// Calls `Gen::gen` with random seed and default parameters. Useful for debugging the
    /// generator.
    fn sample(&self) -> T {
        let mut rng = Rng::random();
        let params = Params::default();

        self.gen(&mut rng, &params)
    }
}

impl<T, F> Gen<T> for F
where
    F: Fn(&mut Rng, &Params) -> T,
{
    fn gen(&self, rng: &mut Rng, params: &Params) -> T {
        self(rng, params)
    }
}

/// Default implementation for `Gen::map`.
pub struct GenMap<T, U, G, F>
where
    G: Gen<T>,
    F: Fn(T) -> U,
{
    g: G,
    f: F,
    _t: PhantomData<T>,
    _u: PhantomData<U>,
}

impl<T, U, G, F> GenOnce<U> for GenMap<T, U, G, F>
where
    G: Gen<T>,
    F: Fn(T) -> U,
{
    fn gen_once(self, rng: &mut Rng, params: &Params) -> U {
        self.gen(rng, params)
    }
}

impl<T, U, G, F> Gen<U> for GenMap<T, U, G, F>
where
    G: Gen<T>,
    F: Fn(T) -> U,
{
    fn gen(&self, rng: &mut Rng, params: &Params) -> U {
        let g = &self.g;
        let f = &self.f;

        let t = g.gen(rng, params);
        let u = f(t);

        u
    }
}

/// Default implementation for `Gen::flatten`.
pub struct GenFlatten<T, GT, GGT>
where
    GT: GenOnce<T>,
    GGT: Gen<GT>,
{
    ggt: GGT,
    _t: PhantomData<T>,
    _gt: PhantomData<GT>,
}

impl<T, GT, GGT> Gen<T> for GenFlatten<T, GT, GGT>
where
    GT: GenOnce<T>,
    GGT: Gen<GT>,
{
    fn gen(&self, rng: &mut Rng, params: &Params) -> T {
        let ggt = &self.ggt;

        let gt = ggt.gen(rng, params);
        let t = gt.gen_once(rng, params);

        t
    }
}

impl<T, GT, GGT> GenOnce<T> for GenFlatten<T, GT, GGT>
where
    GT: GenOnce<T>,
    GGT: Gen<GT>,
{
    fn gen_once(self, rng: &mut Rng, params: &Params) -> T {
        self.gen(rng, params)
    }
}

/// Default implementation for `Gen::flat_map`.
pub struct GenFlatMap<T, U, GT, GU, F>
where
    GT: Gen<T>,
    GU: GenOnce<U>,
    F: Fn(T) -> GU,
{
    gt: GT,
    f: F,
    _t: PhantomData<T>,
    _u: PhantomData<U>,
    _gu: PhantomData<GU>,
}

impl<T, U, GT, GU, F> Gen<U> for GenFlatMap<T, U, GT, GU, F>
where
    GT: Gen<T>,
    GU: GenOnce<U>,
    F: Fn(T) -> GU,
{
    fn gen(&self, rng: &mut Rng, params: &Params) -> U {
        let gt = &self.gt;
        let f = &self.f;

        let t = gt.gen(rng, params);
        let gu = f(t);
        let u = gu.gen_once(rng, params);

        u
    }
}

impl<T, U, GT, GU, F> GenOnce<U> for GenFlatMap<T, U, GT, GU, F>
where
    GT: Gen<T>,
    GU: GenOnce<U>,
    F: Fn(T) -> GU,
{
    fn gen_once(self, rng: &mut Rng, params: &Params) -> U {
        self.gen(rng, params)
    }
}
